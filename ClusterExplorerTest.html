<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IOP Cluster Explorer (Fire Edition v10.8)</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* --- CORE --- */
        * { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Segoe UI', 'Roboto', sans-serif; color: #e2e8f0; }

        /* PHOENIX COLORS */
        :root {
            --phoenix-fire: #ff2a00;
            --phoenix-glow: #ff5500;
            --bg-dark: #050505;
            --bg-panel: #0a0a0a;
            --border-color: #2a2a2a;
        }

        #app { position: absolute; inset: 0; display: flex; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 340px; height: 100%; background: var(--bg-panel); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; z-index: 50; flex-shrink: 0;
            box-shadow: 5px 0 20px rgba(0,0,0,0.9);
        }

        .sb-header { padding: 20px; background: #000; border-bottom: 2px solid var(--phoenix-fire); }
        .sb-sub { font-size: 0.7rem; color: #666; letter-spacing: 0.15em; text-transform: uppercase; margin-bottom: 2px; }
        .sb-title { font-size: 1.1rem; font-weight: 900; color: var(--phoenix-fire); letter-spacing: 0.05em; text-transform: uppercase; text-shadow: 0 0 15px rgba(255, 42, 0, 0.4); }
        
        /* Stylized Tabs */
        .tabs { display: flex; background: #111; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 12px 5px; color: #777; background: none; border: none; cursor: pointer; border-bottom: 3px solid transparent; font-size: 0.8rem; font-weight: 700; transition: 0.2s; letter-spacing: 0.05em; }
        .tab-btn:hover { color: white; background: #1a1a1a; }
        .tab-btn.active { color: var(--phoenix-fire); border-color: var(--phoenix-fire); background: linear-gradient(to top, rgba(255, 42, 0, 0.15), transparent); }

        .sb-content { flex: 1; overflow-y: auto; position: relative; }
        .view { display: none; padding: 15px; }
        .view.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- LIST ITEMS --- */
        .dino-item { 
            display: flex; align-items: center; padding: 10px; 
            border-bottom: 1px solid #1a1a1a; cursor: pointer; transition: 0.15s; border-left: 3px solid transparent;
        }
        .dino-item:hover { background: #151515; border-left-color: #444; }
        .dino-item.active { background: rgba(255, 42, 0, 0.1); border-left-color: var(--phoenix-fire); }
        .dino-icon { width: 32px; height: 32px; object-fit: contain; margin-right: 12px; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5)); }
        .dino-name { font-size: 0.9rem; color: #ddd; font-weight: 500; }

        .toggle-item { display: flex; align-items: center; padding: 8px 0; cursor: pointer; user-select: none; }
        .chk { width: 18px; height: 18px; border: 2px solid #444; border-radius: 3px; margin-right: 10px; display: flex; align-items: center; justify-content: center; transition: 0.2s; background: #000; }
        .toggle-item:hover .chk { border-color: #888; }
        .toggle-item.checked .chk { background: var(--phoenix-fire); border-color: var(--phoenix-fire); box-shadow: 0 0 8px var(--phoenix-fire); }
        .toggle-item.checked .chk::after { content: '✓'; color: black; font-size: 12px; font-weight: bold; }
        .toggle-text { color: #aaa; font-size: 0.9rem; }
        .toggle-item.checked .toggle-text { color: white; }

        /* --- MAP ENGINE --- */
        #viewport {
            flex: 1; position: relative; background: #020202; overflow: hidden;
            display: block; 
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 1024px; height: 1024px;
            box-shadow: 0 0 100px rgba(0,0,0,0.9);
            transform-origin: 0 0; /* WICHTIG: Zoom vom Nullpunkt, wir berechnen den Offset manuell */
            background-color: #050505;
            will-change: transform;
        }

        #layer-image {
            position: absolute; inset: 0; z-index: 1;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        #layer-data {
            position: absolute; inset: 0; z-index: 2;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        #layer-input {
            position: absolute; inset: 0; z-index: 10;
            width: 100%; height: 100%;
            cursor: grab;
        }
        #layer-input:active { cursor: grabbing; }

        /* --- HUD --- */
        .hud-top { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 8px 15px; border-radius: 4px; color: var(--phoenix-fire); font-family: monospace; font-size: 13px; z-index: 50; pointer-events: none; border: 1px solid #333; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .hud-bot { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; z-index: 50; }
        .zoom-btn { width: 42px; height: 42px; background: #111; border: 1px solid #444; color: white; border-radius: 6px; font-size: 22px; cursor: pointer; display: grid; place-items: center; transition: 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .zoom-btn:hover { border-color: var(--phoenix-fire); color: var(--phoenix-fire); background: #222; box-shadow: 0 0 10px rgba(255, 42, 0, 0.2); }

        .loader { position: absolute; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .loader.hidden { opacity: 0; pointer-events: none; }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top-color: var(--phoenix-fire); border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; box-shadow: 0 0 20px rgba(255, 42, 0, 0.3); }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Chat */
        .chat-container { display: flex; flex-direction: column; height: 100%; }
        .chat-log { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .chat-msg { padding: 10px 14px; border-radius: 8px; font-size: 0.9rem; max-width: 85%; line-height: 1.5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .chat-msg.u { align-self: flex-end; background: #333; color: white; border: 1px solid #555; }
        .chat-msg.b { align-self: flex-start; background: #111; color: #ccc; border-left: 3px solid var(--phoenix-fire); }
        .chat-input { display: flex; padding: 15px; border-top: 1px solid #333; gap: 10px; background: #050505; }
        .chat-field { flex: 1; background: #1a1a1a; border: 1px solid #333; color: white; padding: 10px; border-radius: 6px; outline: none; transition: 0.2s; }
        .chat-field:focus { border-color: var(--phoenix-fire); }
        .chat-send { background: var(--phoenix-fire); color: white; border: none; padding: 0 20px; border-radius: 6px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .chat-send:hover { background: var(--phoenix-glow); transform: translateY(-1px); box-shadow: 0 0 10px rgba(255, 42, 0, 0.4); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--phoenix-fire); }
        
        .hidden { display: none !important; }
        
        /* Inputs */
        .phoenix-input { w-full: 100%; background: #050505; border: 1px solid #333; padding: 10px; border-radius: 6px; color: white; outline: none; font-size: 0.9rem; transition: 0.2s; }
        .phoenix-input:focus { border-color: var(--phoenix-fire); box-shadow: 0 0 10px rgba(255, 42, 0, 0.15); }
        
        .phoenix-btn { width: 100%; background: #1f1f1f; border: 1px solid #333; color: #ccc; padding: 10px; border-radius: 6px; cursor: pointer; transition: 0.2s; text-transform: uppercase; font-size: 0.8rem; font-weight: bold; letter-spacing: 0.05em; }
        .phoenix-btn:hover { border-color: var(--phoenix-fire); color: var(--phoenix-fire); background: #252525; }
    </style>
</head>
<body>

<!-- LOADER -->
<div id="loader" class="loader">
    <div class="spinner"></div>
    <div id="loader-msg" class="text-white font-bold text-sm tracking-widest uppercase" style="color: var(--phoenix-fire)">Lade IOP Explorer...</div>
</div>

<div id="app">
    <!-- SIDEBAR -->
    <div id="sidebar">
        <div class="sb-header">
            <div class="sb-sub">INFINITY OF PHOENIX</div>
            <div class="sb-title">CLUSTER EXPLORER</div>
            <select id="map-select" class="phoenix-input mt-3 w-full text-sm">
                <option disabled selected>Karte wählen...</option>
            </select>
        </div>

        <nav class="tabs">
            <button class="tab-btn active" onclick="Tabs.open('dinos')">DINOS</button>
            <button class="tab-btn" onclick="Tabs.open('res')">RES.</button>
            <button class="tab-btn" onclick="Tabs.open('pois')">ORTE</button>
            <button class="tab-btn" onclick="Tabs.open('ai')">✨ AI</button>
            <button class="tab-btn" onclick="Tabs.open('settings')">⚙</button>
        </nav>

        <div class="sb-content custom-scrollbar">
            
            <!-- VIEW: DINOS -->
            <div id="view-dinos" class="view active">
                <div class="sticky top-0 bg-[#0a0a0a] z-10 pb-4">
                    <input type="text" id="dino-search" placeholder="Dino suchen..." class="phoenix-input w-full">
                </div>
                <div id="dino-list-root"></div>
            </div>

            <!-- VIEW: RESOURCES -->
            <div id="view-res" class="view">
                <div class="flex justify-between items-center mb-6 border-b border-gray-800 pb-2">
                    <span class="text-xs font-bold text-gray-500 tracking-wider">RESSOURCEN</span>
                    <button onclick="Resources.clear()" class="text-xs hover:text-white transition" style="color: var(--phoenix-fire)">Reset</button>
                </div>
                <div id="res-list-root"></div>
            </div>

            <!-- VIEW: POIS -->
            <div id="view-pois" class="view">
                <div class="text-xs font-bold text-gray-500 mb-3 mt-2 tracking-wider">ALLGEMEIN</div>
                <div class="toggle-item" id="tog-public" onclick="Layers.toggle('public')">
                    <div class="chk"></div><span>Public Spots</span>
                </div>
                <div class="toggle-item" id="tog-caves" onclick="Layers.toggle('caves')">
                    <div class="chk"></div><span>Höhlen</span>
                </div>

                <div class="text-xs font-bold text-gray-500 mb-3 mt-8 tracking-wider">OBELISKEN</div>
                <div id="obelisk-list-root"></div>
            </div>

            <!-- VIEW: AI -->
            <div id="view-ai" class="view h-full p-0">
                <div class="chat-container">
                    <div id="chat-log" class="chat-log custom-scrollbar">
                        <div class="chat-msg b">Willkommen beim <span style="color: var(--phoenix-fire)">IOP Explorer</span>! Ich kenne die aktuelle Karte. Frag mich etwas!</div>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="ai-input" class="chat-field" placeholder="Deine Frage...">
                        <button onclick="AI.send()" class="chat-send">SENDEN</button>
                    </div>
                </div>
            </div>

            <!-- VIEW: SETTINGS -->
            <div id="view-settings" class="view">
                <div class="text-xs font-bold text-gray-500 mb-3 tracking-wider">ANSICHT</div>
                <button onclick="MapEngine.reset()" class="phoenix-btn mb-6">Karte zentrieren</button>
                
                <div class="text-xs font-bold text-gray-500 mb-3 tracking-wider">LAYER</div>
                <div class="toggle-item" id="tog-players" onclick="Layers.toggle('players')">
                    <div class="chk"></div><span>Spieler Spawns</span>
                </div>
                
                <div class="mt-12 text-center text-xs text-gray-600 font-mono">
                    Infinity of Phoenix<br>Cluster Explorer v10.8
                </div>
            </div>

        </div>
    </div>

    <!-- MAP VIEWPORT -->
    <div id="viewport">
        <!-- WORLD CONTAINER (Movable) -->
        <div id="world">
            <!-- LAYER 1: IMAGE (CSS Background) -->
            <div id="layer-image"></div>
            
            <!-- LAYER 2: DATA (Canvas) -->
            <canvas id="layer-data"></canvas>
            
            <!-- LAYER 3: INPUT (Invisible) -->
            <div id="layer-input"></div>
        </div>

        <!-- HUD -->
        <div class="hud-top">LAT: <span id="lat">00.0</span> | LON: <span id="lon">00.0</span></div>
        <div class="hud-bot">
            <button class="zoom-btn" onclick="MapEngine.reset()">⟲</button>
            <button class="zoom-btn" onclick="MapEngine.zoomIn()">+</button>
            <button class="zoom-btn" onclick="MapEngine.zoomOut()">-</button>
        </div>
    </div>
</div>

<script>
/**
 * IOP WIDGET CORE v10.8 (Smart Zoom)
 */

// CONFIG
const CONFIG = {
    cfg: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/main/MapConfigs/MapConfigs.jsn',
    ico: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/refs/heads/main/Icon_Datenbank/Icondb.jsn',
    txt: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/main/Translation_Datenbank/translationdb.jsn',
    colors: { spawn: 'rgba(255, 42, 0, 0.4)', border: '#ff2a00' }
};

// STORE
const Store = {
    cfg: {},
    map: null,
    data: { dinos: {}, res: {}, pois: [], obs: [], caves: [] },
    icons: {},
    trans: { dinos: {}, res: {} },
    // State
    selDino: null,
    activeRes: new Set(),
    activeObs: new Set(),
    layers: { public: false, caves: false, players: false },
    // View
    scale: 1, x: 0, y: 0
};

// --- MAP ENGINE ---
const MapEngine = {
    el: null,
    bg: null,
    cvs: null,
    ctx: null,
    vp: null,
    iconCache: new Map(),

    init() {
        this.vp = document.getElementById('viewport');
        this.el = document.getElementById('world');
        this.bg = document.getElementById('layer-image');
        this.cvs = document.getElementById('layer-data');
        this.ctx = this.cvs.getContext('2d');
        
        const input = document.getElementById('layer-input');
        let isDrag = false, lx = 0, ly = 0;

        input.addEventListener('mousedown', e => { isDrag = true; lx = e.clientX; ly = e.clientY; input.style.cursor = 'grabbing'; });
        window.addEventListener('mouseup', () => { isDrag = false; input.style.cursor = 'grab'; });
        
        input.addEventListener('mousemove', e => {
            if(isDrag) {
                Store.x += e.clientX - lx;
                Store.y += e.clientY - ly;
                lx = e.clientX; ly = e.clientY;
                this.update();
            }
            
            // HUD Update
            const r = this.el.getBoundingClientRect();
            const lat = ((e.clientY - r.top) / r.height) * 100;
            const lon = ((e.clientX - r.left) / r.width) * 100;
            document.getElementById('lat').textContent = Math.max(0, Math.min(100, lat)).toFixed(1);
            document.getElementById('lon').textContent = Math.max(0, Math.min(100, lon)).toFixed(1);
        });

        input.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            
            // Mouse relative to viewport
            const rect = this.vp.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            this.zoomAt(delta, mx, my);
        });

        window.addEventListener('resize', () => this.resize());
        setTimeout(() => this.resize(), 100);
    },

    resize() {
        const margin = 40;
        const s = Math.min(this.vp.clientWidth, this.vp.clientHeight) - margin;
        const size = Math.max(100, s);

        this.el.style.width = size + 'px';
        this.el.style.height = size + 'px';
        this.cvs.width = size;
        this.cvs.height = size;
        
        // AUTO CENTER CSS
        this.el.style.left = (this.vp.clientWidth - size) / 2 + 'px';
        this.el.style.top = (this.vp.clientHeight - size) / 2 + 'px';

        this.draw(); 
    },

    setImage(url) {
        this.bg.style.backgroundImage = `url('${url}')`;
    },

    update() {
        this.el.style.transform = `translate(${Store.x}px, ${Store.y}px) scale(${Store.scale})`;
    },

    // SMART ZOOM: Zooms towards cx, cy (coordinates relative to viewport)
    zoomAt(factor, cx, cy) {
        const oldScale = Store.scale;
        const newScale = Math.max(0.5, Math.min(10, oldScale * factor));
        
        if (newScale === oldScale) return;

        // Visual position logic:
        // Before zoom, visual offset of point under mouse:
        // P_world = P_base + Translate
        // We want P_mouse relative to P_world to scale.
        
        // Formula: NewTranslate = Mouse - (Mouse - OldTranslate) * (NewScale / OldScale)
        // Adjust for the center offset of the container since translate is relative to that
        
        // Correction: Translate is relative to element origin.
        // Element origin in viewport space is:
        // OriginX = ViewportCenterOffset + Store.x
        // Actually, CSS Transform `translate` adds to the element's layout position.
        // Let's use the offset logic:
        
        const elRect = this.el.getBoundingClientRect();
        
        // Mouse position relative to the element (scaled)
        const mx = cx - elRect.left;
        const my = cy - elRect.top;
        
        // The scale ratio
        const ratio = newScale / oldScale;
        
        // Adjust translation to keep (mx, my) stationary
        // NewX = CurrentX - (MouseX_in_unscaled_coords * (newScale - oldScale))
        
        // Actually simpler with the delta method:
        // We need to shift the map opposite to the zoom direction relative to mouse
        
        // Calculate offset change needed
        // Shift = (Mouse relative to World Origin) * (1 - ratio)
        // Store.x and Store.y are the translation values.
        
        // Since we are scaling around 0,0 (top-left of element), we need to adjust translation
        // so that the point under the mouse stays fixed relative to the viewport.
        
        // Math derivation:
        // WorldX = (MouseX - OffsetLeft - TransX) / Scale
        // We want WorldX to be constant.
        // (MouseX - OffsetLeft - NewTransX) / NewScale = (MouseX - OffsetLeft - OldTransX) / OldScale
        
        const offsetLeft = parseFloat(this.el.style.left) || 0;
        const offsetTop = parseFloat(this.el.style.top) || 0;
        
        const relMouseX = cx - offsetLeft - Store.x;
        const relMouseY = cy - offsetTop - Store.y;
        
        const newX = cx - offsetLeft - (relMouseX * ratio);
        const newY = cy - offsetTop - (relMouseY * ratio);
        
        Store.x = newX;
        Store.y = newY;
        Store.scale = newScale;
        
        this.update();
    },

    zoomIn() { 
        // Zoom to center
        const rect = this.vp.getBoundingClientRect();
        this.zoomAt(1.2, rect.width/2, rect.height/2); 
    },
    
    zoomOut() { 
        const rect = this.vp.getBoundingClientRect();
        this.zoomAt(0.8, rect.width/2, rect.height/2); 
    },

    reset() {
        Store.scale = 1; Store.x = 0; Store.y = 0;
        this.update();
        this.resize(); 
    },
    
    getImg(url) {
        if (!url) return null;
        if (this.iconCache.has(url)) return this.iconCache.get(url);
        const img = new Image();
        img.src = url;
        img.onload = () => { if (Store.activeRes.size > 0 || Store.activeObs.size > 0) this.draw(); };
        this.iconCache.set(url, img);
        return img;
    },
    
    getResIcon(key) { return this.getImg(Store.icons[key]?.iconUrl); },

    draw() {
        const w = this.cvs.width;
        const h = this.cvs.height;
        const ctx = this.ctx;

        ctx.clearRect(0, 0, w, h);

        if(Store.selDino && Store.data.dinos[Store.selDino]) {
            Store.data.dinos[Store.selDino].forEach(z => {
                const x = (z.min.lon/100)*w;
                const y = (z.min.lat/100)*h;
                const zw = ((z.max.lon - z.min.lon)/100)*w;
                const zh = ((z.max.lat - z.min.lat)/100)*h;
                ctx.fillStyle = CONFIG.colors.spawn;
                ctx.fillRect(x, y, zw, zh);
                ctx.strokeStyle = CONFIG.colors.border;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, zw, zh);
            });
        }

        Store.activeRes.forEach(k => {
            if(Store.data.res[k]) {
                const iconImg = this.getResIcon(k);
                const c = {'Metal':'#b87333','Crystal':'#a5f3fc', 'Obsidian':'#000', 'Oil':'#111'}[k]||'#fff';
                
                Store.data.res[k].forEach(p => {
                    const cx = (p.lon/100)*w;
                    const cy = (p.lat/100)*h;
                    
                    const scaleFactor = (p.size || 1) * 1.0; 
                    const size = Math.min(32, 10 + (scaleFactor * 2)); 

                    if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
                        ctx.drawImage(iconImg, cx - size/2, cy - size/2, size, size);
                    } else {
                        ctx.fillStyle = c;
                        ctx.beginPath(); ctx.arc(cx, cy, size/4, 0, Math.PI*2); ctx.fill();
                    }
                });
            }
        });

        if(Store.layers.public) this.drawPois(Store.data.pois, '#ff2a00', w, h); 
        if(Store.layers.caves) this.drawPois(Store.data.caves, '#a855f7', w, h);
        
        Store.activeObs.forEach(k => {
            const o = Store.data.obs.find(i => i.name === k);
            if(o) {
                const obImg = o.icon ? this.getImg(o.icon) : null;
                const cx = (o.lon/100)*w;
                const cy = (o.lat/100)*h;

                if (obImg && obImg.complete && obImg.naturalWidth > 0) {
                     const height = 60;
                     const ratio = obImg.naturalWidth / obImg.naturalHeight;
                     const width = height * ratio;
                     ctx.drawImage(obImg, cx - width/2, cy - height, width, height);
                } else {
                    const color = o.name.includes('Rot') ? '#ef4444' : o.name.includes('Grün') ? '#22c55e' : '#3b82f6';
                    ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI*2);
                    ctx.fillStyle = color; ctx.fill();
                    ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
                }
            }
        });
    },

    drawPois(list, c, w, h) { list.forEach(p => this.drawPoi(p.lon, p.lat, c, w, h)); },

    drawPoi(lon, lat, c, w, h, r=5) {
        const ctx = this.ctx;
        const x = (lon/100)*w;
        const y = (lat/100)*h;
        ctx.fillStyle = c;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    }
};

// --- LOGIC ---
const App = {
    async init() {
        MapEngine.init();
        try {
            const [cfg, ic, tr] = await Promise.all([
                fetchData(CONFIG.cfg), fetchData(CONFIG.ico), fetchData(CONFIG.txt)
            ]);
            
            if(!cfg) throw new Error("Config Error");
            
            Store.cfg = cfg;
            
            Store.icons = { ...(ic?.Items||{}), ...(ic?.Kreaturen||{}), ...(ic?.Ressourcen||{}) };
            if(tr) { Store.trans.res = tr.Ressourcen||{}; Store.trans.dinos = tr.Kreaturen||{}; }

            const sel = document.getElementById('map-select');
            Object.keys(cfg).forEach(k => {
                if(cfg[k].activated) {
                    const o = document.createElement('option');
                    o.value = k; o.textContent = cfg[k].displayName;
                    sel.appendChild(o);
                }
            });
            sel.onchange = e => this.loadMap(e.target.value);

            this.loadMap('TheIsland');

        } catch(e) { 
            console.error(e);
            document.getElementById('loader-msg').innerText = "FEHLER BEIM LADEN";
            document.getElementById('loader-msg').classList.add('text-red-500');
        }
    },

    async loadMap(key) {
        const loader = document.getElementById('loader');
        loader.classList.remove('hidden');
        document.getElementById('loader-msg').textContent = `LADE ${Store.cfg[key].displayName}...`;

        const c = Store.cfg[key];
        Store.map = c;
        
        Store.selDino = null; Store.activeRes.clear(); Store.activeObs.clear();
        MapEngine.reset();
        MapEngine.setImage(c.mapImageUrl);

        const urls = [c.creatureDataUrl, c.resourceDataUrl, c.publicSpotsDataUrl, c.obeliskDataUrl, c.caveSpotsDataUrl];
        const [d, r, p, o, ca] = await Promise.all(urls.map(u => fetchData(u).catch(()=>({}))));

        Store.data.dinos = d?.dinoSpawns || {};
        Store.data.res = r?.resources || {};
        Store.data.pois = p?.publicSpots || [];
        Store.data.obs = o?.obelisks || [];
        Store.data.caves = ca?.caveSpots || [];

        Dinos.init();
        Resources.init();
        Layers.initObs();
        MapEngine.draw();
        
        setTimeout(() => {
            loader.classList.add('hidden');
            MapEngine.resize(); 
        }, 800);
    }
};

// --- MODULES ---
const Dinos = {
    init() {
        const list = document.getElementById('dino-list-root');
        list.innerHTML = '';
        const keys = Object.keys(Store.data.dinos).sort();
        this.cache = keys.map(k => ({ key: k, name: Store.trans.dinos[k] || k, icon: Store.icons[k]?.iconUrl }));
        this.render("");
        document.getElementById('dino-search').oninput = e => this.render(e.target.value);
    },

    render(term) {
        const list = document.getElementById('dino-list-root');
        const search = term.toLowerCase();
        const filtered = this.cache.filter(i => i.name.toLowerCase().includes(search));
        const show = search ? filtered : filtered.slice(0, 50);
        
        list.innerHTML = show.map(d => `
            <div class="dino-item ${Store.selDino === d.key ? 'active' : ''}" onclick="Dinos.toggle('${d.key}')">
                <img src="${d.icon || 'https://placehold.co/24'}" class="dino-icon">
                <span class="dino-name">${d.name}</span>
            </div>
        `).join('');
        
        if(!search && filtered.length > 50) {
            list.innerHTML += `<div class="text-xs text-center text-gray-600 p-3 italic">... ${filtered.length - 50} weitere ...</div>`;
        }
    },

    toggle(key) {
        if(Store.selDino === key) Store.selDino = null;
        else Store.selDino = key;
        this.render(document.getElementById('dino-search').value);
        MapEngine.draw();
    }
};

const Resources = {
    init() {
        const list = document.getElementById('res-list-root');
        list.innerHTML = '';
        Object.keys(Store.data.res).sort().forEach(k => {
            const div = document.createElement('div');
            div.className = 'toggle-item';
            const iconUrl = Store.icons[k]?.iconUrl;
            const iconHTML = iconUrl ? `<img src="${iconUrl}" style="width:20px;height:20px;margin-right:10px;object-fit:contain;">` : `<div class="chk"></div>`;
            div.innerHTML = `${iconHTML}<span class="toggle-text">${Store.trans.res[k] || k}</span>`;
            div.onclick = () => {
                if(Store.activeRes.has(k)) { Store.activeRes.delete(k); div.classList.remove('checked'); }
                else { Store.activeRes.add(k); div.classList.add('checked'); }
                MapEngine.draw();
            };
            list.appendChild(div);
        });
    },
    clear() {
        Store.activeRes.clear();
        document.querySelectorAll('#res-list-root .toggle-item').forEach(e => e.classList.remove('checked'));
        MapEngine.draw();
    }
};

const Layers = {
    initObs() {
        const list = document.getElementById('obelisk-list-root');
        list.innerHTML = '';
        Store.data.obs.forEach(o => {
            const div = document.createElement('div');
            div.className = 'toggle-item';
            div.innerHTML = `<div class="chk"></div><span class="toggle-text">${o.name}</span>`;
            div.onclick = () => {
                if(Store.activeObs.has(o.name)) { Store.activeObs.delete(o.name); div.classList.remove('checked'); }
                else { Store.activeObs.add(o.name); div.classList.add('checked'); }
                MapEngine.draw();
            };
            list.appendChild(div);
        });
    },
    toggle(key) {
        Store.layers[key] = !Store.layers[key];
        document.getElementById('tog-'+key).classList.toggle('checked');
        MapEngine.draw();
    }
};

const Tabs = {
    open(id) {
        document.querySelectorAll('.tab-btn').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.view').forEach(e => e.classList.remove('active'));
        const idx = ['dinos','res','pois','ai','settings'].indexOf(id);
        if(idx>=0) document.querySelectorAll('.tab-btn')[idx].classList.add('active');
        document.getElementById('view-'+id).classList.add('active');
        setTimeout(() => MapEngine.resize(), 10);
    }
};

async function fetchData(url) {
    try {
        const r = await fetch(url);
        const t = await r.text();
        return JSON.parse(t.replace(/^\uFEFF/, '').replace(/\u00A0/g, ' '));
    } catch { return null; }
}

const AI = {
    async send() {
        const inp = document.getElementById('ai-input');
        const txt = inp.value.trim();
        if(!txt) return;
        const log = document.getElementById('chat-log');
        log.innerHTML += `<div class="chat-msg u">${txt}</div>`;
        inp.value = '';
        const apiKey = ""; 
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        const context = `Map: ${Store.map?.displayName}. Selected Dino: ${Store.selDino || 'None'}.`;
        try {
            const res = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({contents:[{parts:[{text:txt}]}], systemInstruction: { parts: [{ text: `ARK Survival Expert. German. Context: ${context}` }] }})});
            const d = await res.json();
            log.innerHTML += `<div class="chat-msg b">${d.candidates[0].content.parts[0].text}</div>`;
        } catch { log.innerHTML += `<div class="chat-msg b text-red-500">Error</div>`; }
    }
};

document.addEventListener("DOMContentLoaded", () => App.init());

</script>
</body>
</html>
