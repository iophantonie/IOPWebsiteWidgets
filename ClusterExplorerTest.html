<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IOP Cluster Widget v3.0 (Engine Rewrite)</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* CORE LAYOUT */
        * { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #020408; font-family: 'Segoe UI', sans-serif; color: #e2e8f0; }
        
        .app-shell { display: grid; grid-template-columns: 320px 1fr; height: 100vh; width: 100vw; }
        
        /* SIDEBAR */
        .sidebar { background: #111827; border-right: 1px solid #374151; display: flex; flex-direction: column; z-index: 50; box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
        .sidebar-header { padding: 16px; background: #0f172a; border-bottom: 1px solid #374151; }
        
        /* TABS */
        .tabs-nav { display: flex; background: #1f2937; }
        .tab-btn { flex: 1; padding: 12px; background: transparent; border: none; color: #9ca3af; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; font-size: 0.9rem; font-weight: 600; }
        .tab-btn:hover { color: #f3f4f6; background: #374151; }
        .tab-btn.active { color: #fbbf24; border-bottom-color: #fbbf24; background: #374151; }
        
        .sidebar-content { flex: 1; overflow-y: auto; padding: 16px; position: relative; }
        .tab-view { display: none; }
        .tab-view.active { display: block; animation: fadeEffect 0.3s; }
        @keyframes fadeEffect { from { opacity: 0; } to { opacity: 1; } }

        /* MAP ENGINE AREA */
        .viewport { 
            position: relative; 
            background: #000; 
            overflow: hidden; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center;
        }
        
        /* The Canvas Stack Container */
        .render-target { 
            position: relative; 
            box-shadow: 0 0 100px rgba(0,0,0,0.9);
            /* Debug Border to see if container exists */
            /* border: 1px solid #333; */ 
        }
        
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #input-layer { pointer-events: auto; cursor: grab; }
        #input-layer:active { cursor: grabbing; }

        /* UI COMPONENTS */
        .ui-panel { background: rgba(17, 24, 39, 0.95); border: 1px solid #374151; padding: 10px; border-radius: 6px; backdrop-filter: blur(4px); }
        
        .hud-coords { position: absolute; top: 20px; right: 20px; color: #fbbf24; font-family: monospace; z-index: 100; pointer-events: none; }
        .hud-zoom { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 8px; z-index: 100; }
        .zoom-btn { width: 40px; height: 40px; background: #1f2937; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 1.5rem; cursor: pointer; display: grid; place-items: center; }
        .zoom-btn:hover { background: #fbbf24; color: black; border-color: #fbbf24; }

        /* DATA LISTS */
        .list-item { padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; margin-bottom: 4px; transition: 0.2s; }
        .list-item:hover { background: #374151; }
        .list-item.selected { background: rgba(251, 191, 36, 0.2); border-left: 3px solid #fbbf24; }
        .list-item img { width: 28px; height: 28px; margin-right: 12px; object-fit: contain; }

        /* TOGGLES */
        .toggle-row { display: flex; align-items: center; margin-bottom: 12px; user-select: none; cursor: pointer; }
        .checkbox-custom { width: 18px; height: 18px; border: 2px solid #4b5563; border-radius: 4px; margin-right: 10px; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .toggle-row.active .checkbox-custom { background: #fbbf24; border-color: #fbbf24; }
        .toggle-row.active .checkbox-custom::after { content: '✔'; font-size: 12px; color: black; }
        .toggle-label { font-size: 0.95rem; color: #d1d5db; }

        /* LOADING SCREEN */
        .loader { position: absolute; inset: 0; background: #020408; z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; pointer-events: none; }
        .loader.hidden { opacity: 0; }
        .spinner { width: 50px; height: 50px; border: 4px solid #333; border-top-color: #fbbf24; border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* SCROLLBAR */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
        
        /* INFO PANEL */
        .info-panel { position: absolute; top: 0; right: 0; bottom: 0; width: 360px; background: #111827; border-left: 1px solid #fbbf24; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 150; box-shadow: -10px 0 30px rgba(0,0,0,0.8); display: flex; flex-direction: column; }
        .info-panel.visible { transform: translateX(0); }
        .info-header { padding: 20px; background: #1f2937; border-bottom: 1px solid #374151; display: flex; justify-content: space-between; align-items: start; }
        .info-body { padding: 20px; overflow-y: auto; flex: 1; }
        .close-btn { background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 1.5rem; }
        .close-btn:hover { color: white; }

        /* AI CHAT */
        .chat-box { display: flex; flex-direction: column; height: 100%; }
        .chat-log { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 12px; }
        .msg { padding: 10px 14px; border-radius: 8px; font-size: 0.9rem; max-width: 90%; line-height: 1.5; }
        .msg.user { background: #2563eb; color: white; align-self: flex-end; }
        .msg.bot { background: #374151; color: #e5e7eb; align-self: flex-start; border-left: 3px solid #fbbf24; }
        .chat-input { display: flex; gap: 8px; padding-top: 10px; border-top: 1px solid #374151; }
        .chat-input input { flex: 1; background: #1f2937; border: 1px solid #4b5563; padding: 8px; border-radius: 4px; color: white; }
        .chat-input button { background: #fbbf24; color: black; border: none; padding: 0 16px; border-radius: 4px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<!-- LOADING OVERLAY -->
<div id="loader" class="loader">
    <div class="spinner"></div>
    <div id="loading-status" class="mt-4 text-amber-500 font-mono text-sm">Systemstart...</div>
</div>

<div class="app-shell">
    <!-- LEFT SIDEBAR -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <h1 class="text-xl font-bold text-amber-500 tracking-wide">IOP CLUSTER</h1>
            <div class="mt-2 relative group">
                <button id="map-select-btn" class="text-xs text-gray-400 hover:text-white flex items-center w-full justify-between bg-gray-800 p-2 rounded">
                    <span id="current-map-name">Lade...</span> <span>▼</span>
                </button>
                <div id="map-dropdown" class="hidden absolute top-full left-0 w-full bg-gray-800 border border-gray-600 rounded mt-1 z-50 max-h-60 overflow-y-auto"></div>
            </div>
        </div>

        <div class="tabs-nav">
            <button class="tab-btn active" onclick="app.switchTab('dinos')">DINOS</button>
            <button class="tab-btn" onclick="app.switchTab('resources')">RES.</button>
            <button class="tab-btn" onclick="app.switchTab('pois')">ORTE</button>
            <button class="tab-btn" onclick="app.switchTab('ai')">✨ AI</button>
            <button class="tab-btn" onclick="app.switchTab('settings')">⚙</button>
        </div>

        <div class="sidebar-content custom-scrollbar">
            
            <!-- DINOS TAB -->
            <div id="tab-dinos" class="tab-view active">
                <input type="text" id="dino-search" placeholder="Suche..." class="w-full bg-gray-800 border border-gray-600 rounded p-2 text-white mb-4 focus:border-amber-500 outline-none">
                <div id="dino-list"></div>
            </div>

            <!-- RESOURCES TAB -->
            <div id="tab-resources" class="tab-view">
                <div class="flex items-center justify-between mb-4 pb-2 border-b border-gray-700">
                    <span class="text-xs font-bold text-gray-500 uppercase">Ressourcen</span>
                    <button onclick="app.toggleAllResources()" class="text-xs text-amber-500 hover:text-amber-400">Alle Umschalten</button>
                </div>
                <div id="resource-list"></div>
            </div>

            <!-- POIS TAB -->
            <div id="tab-pois" class="tab-view">
                <div class="mb-6">
                    <div class="text-xs font-bold text-gray-500 uppercase mb-3">Allgemein</div>
                    <div class="toggle-row" onclick="app.toggleLayer('publicSpots')">
                        <div class="checkbox-custom" id="cb-publicSpots"></div>
                        <span class="toggle-label">Public Spots</span>
                    </div>
                    <div class="toggle-row" onclick="app.toggleLayer('caves')">
                        <div class="checkbox-custom" id="cb-caves"></div>
                        <span class="toggle-label">Höhlen</span>
                    </div>
                </div>
                <div>
                    <div class="text-xs font-bold text-gray-500 uppercase mb-3">Obelisken</div>
                    <div id="obelisk-list"></div>
                </div>
            </div>

            <!-- AI TAB -->
            <div id="tab-ai" class="tab-view h-full">
                <div class="chat-box">
                    <div id="chat-log" class="chat-log custom-scrollbar">
                        <div class="msg bot">Hallo Survivor! Ich kenne mich auf <strong id="ai-map-ref">dieser Karte</strong> bestens aus. Frag mich etwas!</div>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="ai-input" placeholder="Nachricht...">
                        <button onclick="app.sendAiMessage()">SENDEN</button>
                    </div>
                </div>
            </div>

            <!-- SETTINGS TAB -->
            <div id="tab-settings" class="tab-view">
                <div class="text-xs font-bold text-gray-500 uppercase mb-3">Layer Optionen</div>
                <div class="toggle-row" onclick="app.toggleLayer('playerSpawns')">
                    <div class="checkbox-custom" id="cb-playerSpawns"></div>
                    <span class="toggle-label">Spieler Spawns</span>
                </div>
                <div class="toggle-row" onclick="app.toggleLayer('notes')">
                    <div class="checkbox-custom" id="cb-notes"></div>
                    <span class="toggle-label">Explorer Notes</span>
                </div>
                <div class="mt-10 text-center text-xs text-gray-600">
                    Engine v3.0 | Status: <span id="engine-status" class="text-green-500">Running</span>
                </div>
            </div>

        </div>
    </aside>

    <!-- MAIN VIEWPORT -->
    <main class="viewport" id="viewport">
        <!-- The Render Target is strictly sized via JS to maintain aspect ratio -->
        <div id="render-target" class="render-target">
            <!-- Layers stack (Canvas 0 is bottom) -->
            <canvas id="layer-map" style="z-index: 0; background: #0f172a;"></canvas> <!-- Base Map -->
            <canvas id="layer-zones" style="z-index: 1;"></canvas> <!-- Spawn Zones -->
            <canvas id="layer-overlays" style="z-index: 2;"></canvas> <!-- Resources, POIs -->
            <canvas id="input-layer" style="z-index: 10;"></canvas> <!-- Mouse Interaction -->
        </div>

        <!-- HUD -->
        <div class="hud-coords ui-panel">
            LAT: <span id="hud-lat">00.0</span> | LON: <span id="hud-lon">00.0</span>
        </div>
        <div class="hud-zoom">
            <button class="zoom-btn" onclick="app.zoomIn()">+</button>
            <button class="zoom-btn" onclick="app.zoomOut()">-</button>
        </div>
    </main>

    <!-- SLIDE-OUT INFO PANEL -->
    <div id="info-panel" class="info-panel">
        <div class="info-header">
            <h2 id="info-title" class="text-xl font-bold text-amber-500">Titel</h2>
            <button class="close-btn" onclick="app.closeInfo()">×</button>
        </div>
        <div id="info-body" class="info-body custom-scrollbar text-gray-300 text-sm leading-relaxed"></div>
    </div>
</div>

<script>
/**
 * IOP CLUSTER WIDGET ENGINE v3.0
 * Fully rewritten to separate State, Logic, and Rendering.
 */

const CONFIG = {
    urls: {
        configs: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/main/MapConfigs/MapConfigs.jsn',
        icons: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/refs/heads/main/Icon_Datenbank/Icondb.jsn',
        trans: 'https://raw.githubusercontent.com/iophantonie/iophantonie-IOP_Custom_Map_Explorer.github.io/main/Translation_Datenbank/translationdb.jsn'
    },
    colors: {
        spawn: 'rgba(251, 191, 36, 0.4)',
        spawnBorder: 'rgba(251, 191, 36, 0.9)',
        highlight: '#fbbf24'
    }
};

// --- APP STATE (Single Source of Truth) ---
const State = {
    currentMapKey: 'TheIsland',
    mapConfig: null,
    mapImage: new Image(),
    isMapLoaded: false,
    
    // Viewport
    scale: 1,
    pan: { x: 0, y: 0 },
    isDragging: false,
    lastMouse: { x: 0, y: 0 },
    
    // Data
    dinos: {},
    resources: {},
    pois: [],
    obelisks: [],
    caves: [],
    
    // Selection / Filters
    selectedDino: null,
    activeResources: new Set(),
    activeObelisks: new Set(),
    layers: {
        publicSpots: false,
        caves: false,
        playerSpawns: false,
        notes: false
    },
    
    // Assets
    icons: {},
    translations: { res: {}, dinos: {} }
};

// --- ENGINE CORE ---
const Engine = {
    ctx: {}, // Canvas Contexts
    canvases: {},

    init() {
        // Setup Contexts
        ['map', 'zones', 'overlays', 'input'].forEach(id => {
            const el = document.getElementById(id === 'input' ? 'input-layer' : `layer-${id}`);
            this.canvases[id] = el;
            if(id !== 'input') this.ctx[id] = el.getContext('2d');
        });

        // Event Listeners
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        // Start Loop
        this.resize();
        this.renderLoop();
    },

    resize() {
        const viewport = document.getElementById('viewport');
        const target = document.getElementById('render-target');
        
        // Determine square size that fits
        const size = Math.min(viewport.clientWidth, viewport.clientHeight);
        
        target.style.width = size + 'px';
        target.style.height = size + 'px';

        // Resize all canvases
        Object.values(this.canvases).forEach(cvs => {
            cvs.width = size;
            cvs.height = size;
        });

        this.requestRender();
    },

    setupInput() {
        const cvs = this.canvases.input;
        
        cvs.addEventListener('mousedown', e => {
            State.isDragging = true;
            State.lastMouse = { x: e.clientX, y: e.clientY };
            cvs.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            State.isDragging = false;
            cvs.style.cursor = 'grab';
        });

        cvs.addEventListener('mousemove', e => {
            // HUD Update
            const rect = cvs.getBoundingClientRect();
            const x = (e.clientX - rect.left - State.pan.x) / State.scale;
            const y = (e.clientY - rect.top - State.pan.y) / State.scale;
            
            // Convert to Game Coords (0-100)
            const lat = (y / cvs.height) * 100;
            const lon = (x / cvs.width) * 100;
            
            document.getElementById('hud-lat').textContent = Math.max(0, Math.min(100, lat)).toFixed(1);
            document.getElementById('hud-lon').textContent = Math.max(0, Math.min(100, lon)).toFixed(1);

            // Pan Logic
            if(State.isDragging) {
                const dx = e.clientX - State.lastMouse.x;
                const dy = e.clientY - State.lastMouse.y;
                State.pan.x += dx;
                State.pan.y += dy;
                State.lastMouse = { x: e.clientX, y: e.clientY };
                this.requestRender();
            }
        });

        cvs.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? (1 - zoomSpeed) : (1 + zoomSpeed);
            
            // Zoom towards mouse logic could go here, simplified centered zoom for stability
            State.scale *= delta;
            State.scale = Math.max(1, Math.min(10, State.scale));
            
            // Clamp Pan (Keep map in view) - Simplified
            // State.pan.x = Math.min(0, Math.max(cvs.width * (1 - State.scale), State.pan.x));
            
            this.requestRender();
        });

        cvs.addEventListener('click', e => {
            if (State.isDragging) return; // Prevent click on drag end
            app.handleMapClick(e);
        });
    },

    requestRender() {
        window.requestAnimationFrame(() => this.render());
    },

    render() {
        const w = this.canvases.map.width;
        const h = this.canvases.map.height;

        // 1. CLEAR ALL LAYERS (Crucial for toggling)
        Object.values(this.ctx).forEach(ctx => ctx.clearRect(0, 0, w, h));

        // 2. DRAW BASE MAP
        const ctxMap = this.ctx.map;
        ctxMap.save();
        ctxMap.translate(State.pan.x, State.pan.y);
        ctxMap.scale(State.scale, State.scale);

        if (State.isMapLoaded) {
            ctxMap.drawImage(State.mapImage, 0, 0, w, h);
        } else {
            // Draw placeholder text if map missing
            ctxMap.fillStyle = '#1f2937';
            ctxMap.fillRect(0, 0, w, h);
            ctxMap.fillStyle = '#ef4444';
            ctxMap.font = '20px sans-serif';
            ctxMap.textAlign = 'center';
            ctxMap.fillText("Lade Karte...", w/2, h/2);
        }
        ctxMap.restore();

        // 3. DRAW ZONES (Dinos)
        if (State.selectedDino && State.dinos[State.selectedDino]) {
            const ctxZone = this.ctx.zones;
            ctxZone.save();
            ctxZone.translate(State.pan.x, State.pan.y);
            ctxZone.scale(State.scale, State.scale);
            
            State.dinos[State.selectedDino].forEach(zone => {
                const x = (zone.min.lon / 100) * w;
                const y = (zone.min.lat / 100) * h;
                const zw = ((zone.max.lon - zone.min.lon) / 100) * w;
                const zh = ((zone.max.lat - zone.min.lat) / 100) * h;
                
                ctxZone.fillStyle = CONFIG.colors.spawn;
                ctxZone.fillRect(x, y, zw, zh);
                ctxZone.strokeStyle = CONFIG.colors.spawnBorder;
                ctxZone.lineWidth = 1 / State.scale;
                ctxZone.strokeRect(x, y, zw, zh);
            });
            ctxZone.restore();
        }

        // 4. DRAW OVERLAYS (Resources, POIs)
        const ctxOver = this.ctx.overlays;
        ctxOver.save();
        ctxOver.translate(State.pan.x, State.pan.y);
        ctxOver.scale(State.scale, State.scale);

        // Resources
        State.activeResources.forEach(resKey => {
            if (State.resources[resKey]) {
                const color = {
                    'Metal': '#b87333', 'Crystal': '#a5f3fc', 'Obsidian': '#111', 
                    'Oil': '#1e3a8a', 'Silica Pearls': '#fff'
                }[resKey] || '#fff';
                
                ctxOver.fillStyle = color;
                State.resources[resKey].forEach(node => {
                    const cx = (node.lon / 100) * w;
                    const cy = (node.lat / 100) * h;
                    ctxOver.beginPath();
                    ctxOver.arc(cx, cy, 3 / State.scale, 0, Math.PI * 2);
                    ctxOver.fill();
                });
            }
        });

        // Public Spots
        if (State.layers.publicSpots) {
            State.pois.forEach(spot => {
                const cx = (spot.lon / 100) * w;
                const cy = (spot.lat / 100) * h;
                this.drawPin(ctxOver, cx, cy, '#fbbf24');
            });
        }

        // Caves
        if (State.layers.caves) {
            State.caves.forEach(cave => {
                const cx = (cave.lon / 100) * w;
                const cy = (cave.lat / 100) * h;
                this.drawPin(ctxOver, cx, cy, '#a855f7'); // Purple
            });
        }

        // Obelisks
        State.activeObelisks.forEach(obKey => {
            const ob = State.obelisks.find(o => o.name === obKey);
            if (ob) {
                const cx = (ob.lon / 100) * w;
                const cy = (ob.lat / 100) * h;
                const color = ob.name.includes('Rot') ? '#ef4444' : ob.name.includes('Grün') ? '#22c55e' : '#3b82f6';
                
                ctxOver.beginPath();
                ctxOver.arc(cx, cy, 8 / State.scale, 0, Math.PI * 2);
                ctxOver.fillStyle = color;
                ctxOver.fill();
                ctxOver.lineWidth = 2 / State.scale;
                ctxOver.strokeStyle = '#fff';
                ctxOver.stroke();
            }
        });

        ctxOver.restore();
    },

    drawPin(ctx, x, y, color) {
        const s = 1 / State.scale;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - 5*s, y - 15*s);
        ctx.arc(x, y - 15*s, 5*s, Math.PI, 0);
        ctx.lineTo(x, y);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = s;
        ctx.stroke();
    },

    renderLoop() {
        // Optional: Continuous loop if animations are needed.
        // For now, on-demand render via requestRender() is more efficient.
    }
};

// --- APP CONTROLLER ---
const app = {
    async init() {
        Engine.init();
        
        // Load Base Configs
        try {
            const [mapCfg, icons, trans] = await Promise.all([
                fetchData(CONFIG.urls.configs),
                fetchData(CONFIG.urls.icons),
                fetchData(CONFIG.urls.trans)
            ]);
            
            State.icons = {...icons?.Items, ...icons?.Kreaturen};
            if(trans) {
                State.translations.res = trans.Ressourcen || {};
                State.translations.dinos = trans.Kreaturen || {};
            }
            
            this.buildMapSelector(mapCfg);
            this.loadMap('TheIsland'); // Default
            
        } catch(e) {
            document.getElementById('loading-status').innerText = "Fehler: Configs nicht geladen.";
            console.error(e);
        }
    },

    buildMapSelector(configs) {
        const dd = document.getElementById('map-dropdown');
        for(const k in configs) {
            if(!configs[k].activated) continue;
            const btn = document.createElement('div');
            btn.className = 'p-2 hover:bg-gray-700 cursor-pointer text-sm text-gray-300';
            btn.textContent = configs[k].displayName;
            btn.onclick = () => { 
                this.loadMap(k); 
                document.getElementById('map-dropdown').classList.add('hidden');
            };
            dd.appendChild(btn);
        }
        
        // Toggle Logic
        document.getElementById('map-select-btn').onclick = (e) => {
            e.stopPropagation();
            document.getElementById('map-dropdown').classList.toggle('hidden');
        }
    },

    async loadMap(key) {
        // UI Reset
        document.getElementById('loader').classList.remove('hidden');
        document.getElementById('loading-status').textContent = "Lade Kartendaten...";
        
        // Reset State
        State.currentMapKey = key;
        State.scale = 1; 
        State.pan = {x:0,y:0};
        State.selectedDino = null;
        State.activeResources.clear();
        State.activeObelisks.clear();
        // Reset Checkboxes UI
        document.querySelectorAll('.toggle-row').forEach(el => el.classList.remove('active'));
        
        const cfg = State.mapConfig = mapConfigs[key]; // Assuming mapConfigs is global or fetched
        document.getElementById('current-map-name').textContent = cfg.displayName;
        document.getElementById('ai-map-ref').textContent = cfg.displayName;

        // Image Load (Robust)
        State.isMapLoaded = false;
        State.mapImage.src = cfg.mapImageUrl;
        State.mapImage.onload = () => {
            State.isMapLoaded = true;
            Engine.requestRender();
            document.getElementById('loader').classList.add('hidden');
        };

        // Data Fetching
        try {
            const [dinoData, resData, poiData, obData, caveData] = await Promise.all([
                fetchData(cfg.creatureDataUrl),
                fetchData(cfg.resourceDataUrl),
                fetchData(cfg.publicSpotsDataUrl),
                fetchData(cfg.obeliskDataUrl),
                fetchData(cfg.caveSpotsDataUrl)
            ]);

            State.dinos = dinoData?.dinoSpawns || {};
            State.resources = resData?.resources || {};
            State.pois = poiData?.publicSpots || [];
            State.obelisks = obData?.obelisks || [];
            State.caves = caveData?.caveSpots || [];

            this.updateSidebarUI();
            Engine.requestRender();

        } catch(e) {
            console.error("Data Load Error", e);
            document.getElementById('loading-status').textContent = "Datenfehler!";
        }
    },

    updateSidebarUI() {
        // Dinos
        const dList = document.getElementById('dino-list');
        dList.innerHTML = '';
        
        // Search Filter Logic
        const searchInput = document.getElementById('dino-search');
        const filterDinos = () => {
            const term = searchInput.value.toLowerCase();
            dList.innerHTML = '';
            
            const entries = Object.keys(State.dinos).map(k => ({
                key: k,
                name: State.translations.dinos[k] || k,
                icon: State.icons[k]?.iconUrl
            })).sort((a,b) => a.name.localeCompare(b.name));

            entries.filter(e => e.name.toLowerCase().includes(term)).forEach(e => {
                const el = document.createElement('div');
                el.className = 'list-item';
                if(State.selectedDino === e.key) el.classList.add('selected');
                
                el.innerHTML = `<img src="${e.icon || 'https://placehold.co/32?text=?'}"> <span>${e.name}</span>`;
                el.onclick = () => {
                    State.selectedDino = e.key;
                    // Update UI selection classes
                    Array.from(dList.children).forEach(c => c.classList.remove('selected'));
                    el.classList.add('selected');
                    Engine.requestRender();
                };
                dList.appendChild(el);
            });
        };
        
        searchInput.oninput = filterDinos;
        filterDinos(); // Init

        // Resources
        const rList = document.getElementById('resource-list');
        rList.innerHTML = '';
        Object.keys(State.resources).sort().forEach(r => {
            const div = document.createElement('div');
            div.className = 'toggle-row';
            div.innerHTML = `<div class="checkbox-custom"></div><span class="toggle-label">${State.translations.res[r] || r}</span>`;
            div.onclick = () => {
                if(State.activeResources.has(r)) {
                    State.activeResources.delete(r);
                    div.classList.remove('active');
                } else {
                    State.activeResources.add(r);
                    div.classList.add('active');
                }
                Engine.requestRender();
            };
            rList.appendChild(div);
        });

        // Obelisks
        const oList = document.getElementById('obelisk-list');
        oList.innerHTML = '';
        State.obelisks.forEach(ob => {
            const div = document.createElement('div');
            div.className = 'toggle-row';
            div.innerHTML = `<div class="checkbox-custom"></div><span class="toggle-label">${ob.name}</span>`;
            div.onclick = () => {
                if(State.activeObelisks.has(ob.name)) {
                    State.activeObelisks.delete(ob.name);
                    div.classList.remove('active');
                } else {
                    State.activeObelisks.add(ob.name);
                    div.classList.add('active');
                }
                Engine.requestRender();
            };
            oList.appendChild(div);
        });
    },

    // UI ACTIONS
    switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-view').forEach(v => v.classList.remove('active'));
        
        // Find button by onclick attr logic or structure (Simplified here)
        // In clean DOM usage we would use IDs on buttons, but here we query:
        const btnIndex = ['dinos', 'resources', 'pois', 'ai', 'settings'].indexOf(tabId);
        document.querySelectorAll('.tab-btn')[btnIndex].classList.add('active');
        document.getElementById(`tab-${tabId}`).classList.add('active');
        
        // IMPORTANT: Ensure layout is correct after tab switch
        setTimeout(() => Engine.resize(), 50);
    },

    toggleLayer(layerName) {
        State.layers[layerName] = !State.layers[layerName];
        const el = document.getElementById(`cb-${layerName}`);
        if(el) el.parentElement.classList.toggle('active');
        Engine.requestRender();
    },

    toggleAllResources() {
        const allKeys = Object.keys(State.resources);
        const rList = document.getElementById('resource-list');
        
        if(State.activeResources.size === allKeys.length) {
            State.activeResources.clear(); // Deselect All
            Array.from(rList.children).forEach(c => c.classList.remove('active'));
        } else {
            allKeys.forEach(k => State.activeResources.add(k)); // Select All
            Array.from(rList.children).forEach(c => c.classList.add('active'));
        }
        Engine.requestRender();
    },

    zoomIn() { State.scale = Math.min(10, State.scale * 1.2); Engine.requestRender(); },
    zoomOut() { State.scale = Math.max(1, State.scale / 1.2); Engine.requestRender(); },

    handleMapClick(e) {
        const rect = Engine.canvases.input.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate World Coords relative to rendered map
        const worldX = (mouseX - State.pan.x) / State.scale;
        const worldY = (mouseY - State.pan.y) / State.scale;
        
        const w = Engine.canvases.map.width;
        const h = Engine.canvases.map.height;

        // Check POIs
        if(State.layers.publicSpots) {
            const hit = State.pois.find(p => {
                const px = (p.lon / 100) * w;
                const py = (p.lat / 100) * h;
                const dist = Math.sqrt((worldX-px)**2 + (worldY-py)**2);
                return dist < (15 / State.scale); // Hitbox
            });
            if(hit) this.showInfo(hit);
        }
    },

    showInfo(data) {
        const panel = document.getElementById('info-panel');
        document.getElementById('info-title').textContent = data.name;
        document.getElementById('info-body').innerHTML = `
            <img src="${data.images?.[0] || ''}" class="w-full rounded mb-4 bg-gray-800" onerror="this.style.display='none'">
            <div class="mb-2 text-gray-400">Lat: ${data.lat} / Lon: ${data.lon}</div>
            <p>${data.description || 'Keine Beschreibung.'}</p>
        `;
        panel.classList.add('visible');
    },

    closeInfo() {
        document.getElementById('info-panel').classList.remove('visible');
    },
    
    // AI Chat
    async sendAiMessage() {
        const inp = document.getElementById('ai-input');
        const txt = inp.value.trim();
        if(!txt) return;
        
        const log = document.getElementById('chat-log');
        log.innerHTML += `<div class="msg user">${txt}</div>`;
        inp.value = '';
        log.scrollTop = log.scrollHeight;

        const apiKey = ""; // API KEY HERE
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        const context = `Map: ${State.mapConfig?.displayName}. User looks at: ${State.selectedDino || 'Nothing'}.`;
        
        try {
            const res = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    contents: [{ parts: [{ text: txt }] }],
                    systemInstruction: { parts: [{ text: `You are an ARK Survival Expert. German language. Context: ${context}` }] }
                })
            });
            const data = await res.json();
            const ans = data.candidates?.[0]?.content?.parts?.[0]?.text || "Fehler.";
            log.innerHTML += `<div class="msg bot">${ans.replace(/\n/g, '<br>')}</div>`;
        } catch(e) {
            log.innerHTML += `<div class="msg bot" style="color:red">Verbindungsfehler.</div>`;
        }
        log.scrollTop = log.scrollHeight;
    }
};

// Utils
async function fetchData(url) {
    try {
        const r = await fetch(url);
        const t = await r.text();
        return JSON.parse(t.replace(/^\uFEFF/, '').replace(/\u00A0/g, ' '));
    } catch(e) { return null; }
}

// Global hook for Map Configs (Needed because loadMap expects it)
let mapConfigs = {};
fetchData(CONFIG.urls.configs).then(c => {
    if(c) {
        mapConfigs = c;
        app.init();
    } else {
        document.getElementById('loading-status').textContent = "FATAL: Configs failed.";
    }
});

</script>
</body>
</html>
